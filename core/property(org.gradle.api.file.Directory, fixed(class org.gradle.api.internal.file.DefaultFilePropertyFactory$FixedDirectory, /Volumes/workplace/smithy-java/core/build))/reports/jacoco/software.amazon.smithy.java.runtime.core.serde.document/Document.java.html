<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Document.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">software.amazon.smithy.java.runtime.core.serde.document</a> &gt; <span class="el_source">Document.java</span></div><h1>Document.java</h1><pre class="source lang-java linenums">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package software.amazon.smithy.java.runtime.core.serde.document;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.xml.validation.Schema;
import software.amazon.smithy.java.runtime.core.schema.PreludeSchemas;
import software.amazon.smithy.java.runtime.core.schema.SdkShapeBuilder;
import software.amazon.smithy.java.runtime.core.schema.SerializableShape;
import software.amazon.smithy.java.runtime.core.serde.SdkSerdeException;
import software.amazon.smithy.java.runtime.core.serde.ShapeSerializer;
import software.amazon.smithy.model.shapes.ShapeType;

/**
 * A Smithy document type, representing untyped data from the Smithy data model.
 *
 * &lt;h3&gt;Documents and the Smithy data model&lt;/h3&gt;
 *
 * &lt;p&gt;The Smithy data model consists of:
 *
 * &lt;ul&gt;
 *     &lt;li&gt;Numbers: byte, short, integer, long, float, double, bigInteger, bigDecimal. IntEnum shapes are
 *         represented as integers in the Smithy data model.&lt;/li&gt;
 *     &lt;li&gt;boolean&lt;/li&gt;
 *     &lt;li&gt;blob&lt;/li&gt;
 *     &lt;li&gt;string: enum shapes are represented as strings in the Smithy data model&lt;/li&gt;
 *     &lt;li&gt;timestamp: Represented as an {@link Instant}&lt;/li&gt;
 *     &lt;li&gt;list: list of Documents&lt;/li&gt;
 *     &lt;li&gt;map: map of int|long|string keys to Document values&lt;/li&gt;
 *     &lt;li&gt;struct: structure or union&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Serializing documents and their contents&lt;/h3&gt;
 *
 * &lt;p&gt;A document type implements {@link SerializableShape} and implementations must always call
 * {@link ShapeSerializer#writeDocument}. Shape serializers can access the contents of the document using
 * {@link #serializeContents}, which emits the Smithy data model based on the contents of the document.
 * The first shape written with {@link #serializeContents} must not be a document because doing so would cause
 * infinite recursion in serializers.
 *
 * &lt;h3&gt;Protocol smoothing, string and blob interop&lt;/h3&gt;
 *
 * &lt;p&gt;Document types are a protocol-agnostic view of untyped data. Protocol codecs should attempt to smooth over
 * protocol incompatibilities with the Smithy data model. If a protocol serializes a blob as a base64 encoded string,
 * then calling {@link #asBlob()} should automatically base64 decode the value and return the underlying bytes.
 * Conversely, if a document contains binary encoded data and {@link #asString()} is called, the document should
 * automatically attempt to return a UTF-8 string from the bytes.
 *
 * &lt;h3&gt;Typed documents&lt;/h3&gt;
 *
 * &lt;p&gt;Document types can be combined with a typed schema using {@link #createTyped(SerializableShape)}. This kind of
 * document type allows (but does not require) codecs to serialize or deserialize the document exactly as if the shape
 * itself was serialized or deserialized directly.
 */
public interface Document extends SerializableShape {
    /**
     * Get the Smithy data model type for the underlying contents of the document.
     *
     * &lt;p&gt;The type can be used to know the appropriate &quot;as&quot; method to call to get the underlying data of the document.
     *
     * &lt;p&gt;The type returned from this method will differ from the type and schema emitted from
     * {@link #serialize(ShapeSerializer)}, which always writes the document as {@link ShapeSerializer#writeDocument}.
     * However, the type returned from this method should correspond to the type emitted from
     * {@link #serializeContents(ShapeSerializer)}.
     *
     * &lt;ul&gt;
     *     &lt;li&gt;enum shapes: Enum shapes are treated as a {@link ShapeType#STRING}, and variants can be found in
     *     the corresponding schema emitted from {@link #serializeContents(ShapeSerializer)}.&lt;/li&gt;
     *     &lt;li&gt;intEnum shapes: Enum shapes are treated as an {@link ShapeType#INTEGER}, and variants can be found in
     *     the corresponding schema emitted from {@link #serializeContents(ShapeSerializer)}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the Smithy data model type.
     */
    ShapeType type();

    /**
     * Serializes the Document as a document value in the Smithy data model.
     *
     * &lt;p&gt;All implementations of a document type are expected to follow the same behavior as this method when writing
     * to a {@link ShapeSerializer}; the document is always written with {@link ShapeSerializer#writeDocument(Document)}
     * and receivers are free to query the underlying contents of the document using
     * {@link #serializeContents(ShapeSerializer)}.
     *
     * @param serializer Where to send the document to {@link ShapeSerializer#writeDocument(Document)}.
     */
    @Override
    default void serialize(ShapeSerializer serializer) {
<span class="fc" id="L100">        serializer.writeDocument(this);</span>
<span class="fc" id="L101">    }</span>

    /**
     * Serialize the contents of the document using the Smithy data model and an appropriate {@link Schema}.
     *
     * &lt;p&gt;While {@link #serialize(ShapeSerializer)} always emits document values as
     * {@link ShapeSerializer#writeDocument(Document)}, this method emits the contents of the document itself.
     * {@code ShapeSerializer} implementations that receive a {@link Document} via {@code writeDocument} can get the
     * inner contents of the document using this method.
     *
     * &lt;p&gt;When implementing this method, each call to the serializer must provide the most appropriate schema
     * possible to capture the underlying document value. Documents that are not typed to a specific shape should use
     * schemas from {@link PreludeSchemas}. For example, a string document should use {@link PreludeSchemas#STRING},
     * and an integer document should use {@link PreludeSchemas#INTEGER}.
     *
     * &lt;p&gt;Structure, list, and map documents that are not typed to a specific shape should use
     * {@link PreludeSchemas#DOCUMENT}. Members emitted for these shapes must include an appropriate member name
     * and target shape. For example, to represent the value of a map entry, the value must be emitted as a member
     * schema (even a synthetic member) with a member name of &quot;value&quot; and the document value target
     * (e.g., {@code smithy.api#Document$value}). In doing so, receivers of the document's data model do not need to
     * implement special-cased logic to account for synthetic document type members vs. actual modeled members
     *
     * &lt;p&gt;Implementations must not write the contents of the document as {@link ShapeSerializer#writeDocument(Document)},
     * because that could result in infinite recursion for serializers that want access to the contents of a document.
     *
     * @param serializer Serializer to write the underlying data of the document to.
     */
    void serializeContents(ShapeSerializer serializer);

    /**
     * Get the boolean value of the Document if it is a boolean.
     *
     * @return the boolean value.
     * @throws SdkSerdeException if the Document is not a boolean.
     */
    default boolean asBoolean() {
<span class="fc" id="L137">        throw new SdkSerdeException(&quot;Expected a boolean document, but found &quot; + type());</span>
    }

    /**
     * Get the byte value of the Document if it is a byte.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the byte value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default byte asByte() {
<span class="fc" id="L149">        throw new SdkSerdeException(&quot;Expected a byte document, but found &quot; + type());</span>
    }

    /**
     * Get the short value of the Document if it is a short.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the short value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default short asShort() {
<span class="fc" id="L161">        throw new SdkSerdeException(&quot;Expected a short document, but found &quot; + type());</span>
    }

    /**
     * Get the integer value of the Document if it is an integer.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the integer value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default int asInteger() {
<span class="fc" id="L173">        throw new SdkSerdeException(&quot;Expected an integer document, but found &quot; + type());</span>
    }

    /**
     * Get the long value of the Document if it is a long.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the long value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default long asLong() {
<span class="fc" id="L185">        throw new SdkSerdeException(&quot;Expected a long document, but found &quot; + type());</span>
    }

    /**
     * Get the float value of the Document if it is a float.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the float value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default float asFloat() {
<span class="fc" id="L197">        throw new SdkSerdeException(&quot;Expected a float document, but found &quot; + type());</span>
    }

    /**
     * Get the double value of the Document if it is a double.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the double value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default double asDouble() {
<span class="fc" id="L209">        throw new SdkSerdeException(&quot;Expected a double document, but found &quot; + type());</span>
    }

    /**
     * Get the BigInteger value of the Document if it is a bigInteger.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the BigInteger value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default BigInteger asBigInteger() {
<span class="fc" id="L221">        throw new SdkSerdeException(&quot;Expected a bigInteger document, but found &quot; + type());</span>
    }

    /**
     * Get the BigDecimal value of the Document if it is a bigDecimal.
     *
     * &lt;p&gt;If the value is a number of a different type, the value is cast, which can result in a loss of precision.
     *
     * @return the BigDecimal value.
     * @throws SdkSerdeException if the Document is not a number.
     */
    default BigDecimal asBigDecimal() {
<span class="fc" id="L233">        throw new SdkSerdeException(&quot;Expected a bigDecimal document, but found &quot; + type());</span>
    }

    /**
     * Get the value of the builder as a Number.
     *
     * @return the Number value.
     * @throws SdkSerdeException if the Document is not a numeric type.
     */
    default Number asNumber() {
<span class="fc bfc" id="L243" title="All 9 branches covered.">        return switch (type()) {</span>
<span class="fc" id="L244">            case BYTE -&gt; asByte();</span>
<span class="fc" id="L245">            case SHORT -&gt; asShort();</span>
<span class="fc" id="L246">            case INTEGER -&gt; asInteger();</span>
<span class="fc" id="L247">            case LONG -&gt; asLong();</span>
<span class="fc" id="L248">            case FLOAT -&gt; asFloat();</span>
<span class="fc" id="L249">            case DOUBLE -&gt; asDouble();</span>
<span class="fc" id="L250">            case BIG_INTEGER -&gt; asBigInteger();</span>
<span class="fc" id="L251">            case BIG_DECIMAL -&gt; asBigDecimal();</span>
<span class="fc" id="L252">            default -&gt; throw new SdkSerdeException(&quot;Expected a number document, but found &quot; + type());</span>
        };
    }

    /**
     * Get the string value of the Document if it is a string.
     *
     * &lt;p&gt;If the document is a blob, implementations should attempt to UTF-8 decode the blob value into a string.
     *
     * @return the string value.
     * @throws SdkSerdeException if the Document is not a string.
     */
    default String asString() {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (type() == ShapeType.BLOB) {</span>
<span class="fc" id="L266">            return new String(asBlob(), StandardCharsets.UTF_8);</span>
        }
<span class="fc" id="L268">        throw new SdkSerdeException(&quot;Expected a string document, but found &quot; + type());</span>
    }

    /**
     * Get the Document as a blob if the Document is a blob.
     *
     * &lt;p&gt;If the document is a string, implementations should return the UTF-8 bytes of the string.
     *
     * @return the bytes of the blob.
     * @throws SdkSerdeException if the Document is not a blob.
     */
    default byte[] asBlob() {
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (type() == ShapeType.STRING) {</span>
<span class="fc" id="L281">            return asString().getBytes(StandardCharsets.UTF_8);</span>
        }
<span class="fc" id="L283">        throw new SdkSerdeException(&quot;Expected a blob document, but found &quot; + type());</span>
    }

    /**
     * Get the Document as an Instant if the Document is a timestamp.
     *
     * @return the Instant value of the timestamp.
     * @throws SdkSerdeException if the Document is not a timestamp.
     */
    default Instant asTimestamp() {
<span class="fc" id="L293">        throw new SdkSerdeException(&quot;Expected a timestamp document, but found &quot; + type());</span>
    }

    /**
     * Get the list contents of the Document if it is a list.
     *
     * @return the list contents.
     * @throws SdkSerdeException if the Document is not a list.
     */
    default List&lt;Document&gt; asList() {
<span class="fc" id="L303">        throw new SdkSerdeException(&quot;Expected a list document, but found &quot; + type());</span>
    }

    /**
     * Get the Document as a map of strings to Documents if the Document is a map, a structure, or union.
     *
     * &lt;p&gt;If the Document is a map, and the keys are strings the map entries are returned. If the document is a
     * structure or union, the members of the structure or union are returned as a map where the keys are the
     * member names of each present member.
     *
     * @return the map contents.
     * @throws SdkSerdeException if the Document is not a map, structure, or union or the keys are numbers.
     */
    default Map&lt;String, Document&gt; asStringMap() {
<span class="fc" id="L317">        throw new SdkSerdeException(&quot;Expected a map of strings to documents, but found &quot; + type());</span>
    }

    /**
     * Get a map, struct, or union member from the Document by name.
     *
     * @param memberName Member to access from the Document. For Document types with a schema, this name is the name
     *                   of the member defined in a Smithy model.
     * @return the member, or null if not found.
     * @throws IllegalStateException if the Document is not a string map, structure, or union shape.
     */
    default Document getMember(String memberName) {
<span class="fc" id="L329">        throw new SdkSerdeException(&quot;Expected a map, structure, or union document, but found &quot; + type());</span>
    }

    /**
     * Create a normalized version of the document using normalized document types that aren't tied to any specific
     * protocol or schema.
     *
     * &lt;p&gt;A structure and union document are converted to a map of string to normalized documents. An intEnum is
     * converted to an integer. An enum is converted to a string.
     *
     * @return the normalized document.
     */
    default Document normalize() {
<span class="pc bpc" id="L342" title="13 of 15 branches missed.">        return switch (type()) {</span>
<span class="nc" id="L343">            case BOOLEAN -&gt; createBoolean(asBoolean());</span>
<span class="nc" id="L344">            case BYTE -&gt; createByte(asByte());</span>
<span class="nc" id="L345">            case SHORT -&gt; createShort(asShort());</span>
<span class="nc" id="L346">            case INTEGER, INT_ENUM -&gt; createInteger(asInteger());</span>
<span class="nc" id="L347">            case LONG -&gt; createLong(asLong());</span>
<span class="nc" id="L348">            case FLOAT -&gt; createFloat(asFloat());</span>
<span class="nc" id="L349">            case DOUBLE -&gt; createDouble(asDouble());</span>
<span class="nc" id="L350">            case BIG_INTEGER -&gt; createBigInteger(asBigInteger());</span>
<span class="nc" id="L351">            case BIG_DECIMAL -&gt; createBigDecimal(asBigDecimal());</span>
<span class="fc" id="L352">            case STRING, ENUM -&gt; createString(asString());</span>
<span class="nc" id="L353">            case BLOB -&gt; createBlob(asBlob());</span>
<span class="nc" id="L354">            case TIMESTAMP -&gt; createTimestamp(asTimestamp());</span>
            case STRUCTURE, UNION, MAP -&gt; {
<span class="fc" id="L356">                var map = asStringMap();</span>
<span class="fc" id="L357">                Map&lt;String, Document&gt; result = new LinkedHashMap&lt;&gt;(map.size());</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">                for (var entry : map.entrySet()) {</span>
<span class="fc" id="L359">                    result.put(entry.getKey(), entry.getValue().normalize());</span>
<span class="fc" id="L360">                }</span>
<span class="fc" id="L361">                yield createStringMap(result);</span>
            }
            case LIST -&gt; {
<span class="nc" id="L364">                var list = asList();</span>
<span class="nc" id="L365">                List&lt;Document&gt; result = new ArrayList&lt;&gt;(list.size());</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                for (var element : list) {</span>
<span class="nc" id="L367">                    result.add(element.normalize());</span>
<span class="nc" id="L368">                }</span>
<span class="nc" id="L369">                yield createList(result);</span>
            }
<span class="nc" id="L371">            default -&gt; throw new UnsupportedOperationException(&quot;Unable to normalize document: &quot; + this);</span>
        };
    }

    /**
     * Attempt to deserialize the Document into a builder.
     *
     * @param builder Builder to populate from the Document.
     * @param &lt;T&gt; Shape type to build.
     */
    default &lt;T extends SerializableShape&gt; void deserializeInto(SdkShapeBuilder&lt;T&gt; builder) {
<span class="fc" id="L382">        builder.deserialize(new DocumentDeserializer(this));</span>
<span class="fc" id="L383">    }</span>

    /**
     * Attempt to deserialize the Document into a builder and create the shape.
     *
     * @param builder Builder to populate from the Document.
     * @return the built and error-corrected shape.
     * @param &lt;T&gt; Shape type to build.
     */
    default &lt;T extends SerializableShape&gt; T asShape(SdkShapeBuilder&lt;T&gt; builder) {
<span class="fc" id="L393">        deserializeInto(builder);</span>
<span class="fc" id="L394">        return builder.errorCorrection().build();</span>
    }

    /**
     * Create a byte Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createByte(byte value) {
<span class="fc" id="L404">        return new Documents.ByteDocument(PreludeSchemas.BYTE, value);</span>
    }

    /**
     * Create a short Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createShort(short value) {
<span class="fc" id="L414">        return new Documents.ShortDocument(PreludeSchemas.SHORT, value);</span>
    }

    /**
     * Create an integer Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createInteger(int value) {
<span class="fc" id="L424">        return new Documents.IntegerDocument(PreludeSchemas.INTEGER, value);</span>
    }

    /**
     * Create a long Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createLong(long value) {
<span class="fc" id="L434">        return new Documents.LongDocument(PreludeSchemas.LONG, value);</span>
    }

    /**
     * Create a float Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createFloat(float value) {
<span class="fc" id="L444">        return new Documents.FloatDocument(PreludeSchemas.FLOAT, value);</span>
    }

    /**
     * Create a double Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createDouble(double value) {
<span class="fc" id="L454">        return new Documents.DoubleDocument(PreludeSchemas.DOUBLE, value);</span>
    }

    /**
     * Create a bigInteger Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createBigInteger(BigInteger value) {
<span class="fc" id="L464">        return new Documents.BigIntegerDocument(PreludeSchemas.BIG_INTEGER, value);</span>
    }

    /**
     * Create a bigDecimal Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createBigDecimal(BigDecimal value) {
<span class="fc" id="L474">        return new Documents.BigDecimalDocument(PreludeSchemas.BIG_DECIMAL, value);</span>
    }

    /**
     * Create a boolean Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createBoolean(boolean value) {
<span class="fc" id="L484">        return new Documents.BooleanDocument(PreludeSchemas.BOOLEAN, value);</span>
    }

    /**
     * Create a string Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createString(String value) {
<span class="fc" id="L494">        return new Documents.StringDocument(PreludeSchemas.STRING, value);</span>
    }

    /**
     * Create a blob Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createBlob(byte[] value) {
<span class="fc" id="L504">        return new Documents.BlobDocument(PreludeSchemas.BLOB, value);</span>
    }

    /**
     * Create a timestamp Document.
     *
     * @param value Value to wrap.
     * @return the Document type.
     */
    static Document createTimestamp(Instant value) {
<span class="fc" id="L514">        return new Documents.TimestampDocument(PreludeSchemas.TIMESTAMP, value);</span>
    }

    /**
     * Create a list Document.
     *
     * @param values Values to wrap.
     * @return the Document type.
     */
    static Document createList(List&lt;Document&gt; values) {
<span class="fc" id="L524">        return new Documents.ListDocument(Documents.LIST_SCHEMA, values);</span>
    }

    /**
     * Create a Document for a map of strings to Documents.
     *
     * @param members Members to wrap.
     * @return the Document type.
     */
    static Document createStringMap(Map&lt;String, Document&gt; members) {
<span class="fc" id="L534">        return new Documents.StringMapDocument(Documents.STR_MAP_SCHEMA, members);</span>
    }

    /**
     * Create a Document from a {@link SerializableShape}.
     *
     * &lt;p&gt;The created document is &lt;em&gt;typed&lt;/em&gt; and captures the state of the shape exactly; meaning if the document
     * is serialized or deserialized by a codec, it'd done so exactly as if the underlying shape was serialized or
     * deserialized.
     *
     * @param shape Shape to turn into a Document.
     * @return the Document type.
     */
    static Document createTyped(SerializableShape shape) {
<span class="fc" id="L548">        return new Documents.LazilyCreatedTypedDocument(shape);</span>
    }

    /**
     * Determines if two documents are equal, ignoring schemas and protocol details.
     *
     * @param left  Left document to compare.
     * @param right Right document to compare.
     * @return true if they are equal.
     */
    static boolean equals(Object left, Object right) {
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (left instanceof Document l) {</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            if (right instanceof Document r) {</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (l == r) {</span>
<span class="fc" id="L562">                    return true;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                } else if (l.type() != r.type()) {</span>
<span class="fc" id="L564">                    return false;</span>
                }
<span class="pc bpc" id="L566" title="1 of 15 branches missed.">                return switch (l.type()) {</span>
<span class="fc" id="L567">                    case BLOB -&gt; Arrays.equals(l.asBlob(), r.asBlob());</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">                    case BOOLEAN -&gt; l.asBoolean() == r.asBoolean();</span>
<span class="fc" id="L569">                    case STRING, ENUM -&gt; l.asString().equals(r.asString());</span>
<span class="fc" id="L570">                    case TIMESTAMP -&gt; l.asTimestamp().equals(r.asTimestamp());</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">                    case BYTE -&gt; l.asByte() == r.asByte();</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">                    case SHORT -&gt; l.asShort() == r.asShort();</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    case INTEGER, INT_ENUM -&gt; l.asInteger() == r.asInteger();</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                    case LONG -&gt; l.asLong() == r.asLong();</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                    case FLOAT -&gt; l.asFloat() == r.asFloat();</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">                    case DOUBLE -&gt; l.asDouble() == r.asDouble();</span>
<span class="fc" id="L577">                    case BIG_DECIMAL -&gt; l.asBigDecimal().equals(r.asBigDecimal());</span>
<span class="fc" id="L578">                    case BIG_INTEGER -&gt; l.asBigInteger().equals(r.asBigInteger());</span>
                    case LIST, SET -&gt; {
<span class="fc" id="L580">                        var ll = l.asList();</span>
<span class="fc" id="L581">                        var rl = r.asList();</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                        if (ll.size() != rl.size()) {</span>
<span class="fc" id="L583">                            yield false;</span>
                        }
<span class="fc bfc" id="L585" title="All 2 branches covered.">                        for (int i = 0; i &lt; ll.size(); i++) {</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                            if (!equals(ll.get(i), rl.get(i))) {</span>
<span class="fc" id="L587">                                yield false;</span>
                            }
                        }
<span class="fc" id="L590">                        yield true;</span>
                    }
                    case MAP, STRUCTURE, UNION -&gt; {
<span class="fc" id="L593">                        var lm = l.asStringMap();</span>
<span class="fc" id="L594">                        var rm = r.asStringMap();</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                        if (lm.size() != rm.size()) {</span>
<span class="fc" id="L596">                            yield false;</span>
                        }
<span class="fc bfc" id="L598" title="All 2 branches covered.">                        for (var entry : lm.entrySet()) {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                            if (!equals(entry.getValue(), rm.get(entry.getKey()))) {</span>
<span class="fc" id="L600">                                yield false;</span>
                            }
<span class="fc" id="L602">                        }</span>
<span class="fc" id="L603">                        yield true;</span>
                    }
<span class="nc" id="L605">                    default -&gt; false; // unexpected type (DOCUMENT, MEMBER, OPERATION, SERVICE).</span>
                };
            }
        }
<span class="nc" id="L609">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>