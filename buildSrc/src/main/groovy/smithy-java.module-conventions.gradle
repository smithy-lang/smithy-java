
plugins {
    id 'smithy-java.java-conventions'
    id 'jacoco'
}

def smithyJavaVersion = project.file("${project.rootDir}/VERSION").getText().replace(System.lineSeparator(), "")

group = "software.amazon.smithy.java"
version = smithyJavaVersion

/*
 * Licensing
 * ============================
 */
// Reusable license copySpec
def licenseSpec = copySpec {
    from("${project.rootDir}/LICENSE")
    from("${project.rootDir}/NOTICE")
}

/*
 * Extra Jars
 * ============================
 */
// Build a javadoc JAR too.
tasks.register('javadocJar', Jar) {
    from {
        tasks.javadoc
    }
    archiveClassifier = "javadoc"
}

// TODO: Remove this once package is ready for docs
// Suppress warnings in javadocs
tasks.withType(Javadoc).configureEach {
    (options as StandardJavadocDocletOptions).addStringOption("Xdoclint:-html", "-quiet")
}

// Include an Automatic-Module-Name in all JARs.
afterEvaluate { project ->
    tasks.withType(Jar).configureEach {
        metaInf.with(licenseSpec)
        inputs.property("moduleName", project.ext["moduleName"])
        manifest {
            attributes "Automatic-Module-Name": project.ext["moduleName"]
        }
    }
}

// Always run javadoc after build.
tasks.named("build") {
    dependsOn(tasks.named("javadoc"))
}

/*
 * Code coverage
 * ====================================================
 *
 * Create code coverage reports after running tests.
 */
// Always run the jacoco test report after testing.
tasks.named("test") {
    finalizedBy(tasks.named("jacocoTestReport"))
}

// Configure jacoco to generate an HTML report.
tasks.jacocoTestReport {
    reports {
        xml.required.set(false)
        csv.required.set(false)
        html.outputLocation.set(file("$buildDir/reports/jacoco"))
    }
}
